{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Accueil: Documentation pr\u00e9-processing du Panel L\u00e9manique","text":"<p>Initi\u00e9 par la facult\u00e9 ENAC de l'EPFL, le Panel L\u00e9manique est une \u00e9tude lanc\u00e9e en 2021 pour une dur\u00e9e de 5 ans. Il a pour but de mesurer l\u2019\u00e9volution des comportements, des usages et des opinions sur des modes de vie \u00e0 la mani\u00e8re d\u2019un observatoire. Il aborde entre autres les th\u00e9matiques de la mobilit\u00e9 (quotidienne et \u00e0 fins r\u00e9cr\u00e9atives), du logement, du t\u00e9l\u00e9travail et de la consommation \u00e9nerg\u00e9tique.</p> <p>Le Panel L\u00e9manique couvre l\u2019enti\u00e8ret\u00e9 du territoire des cantons de Vaud et de Gen\u00e8ve. Il s\u2019\u00e9tend \u00e9galement dans le p\u00e9rim\u00e8tre du Grand Gen\u00e8ve, couvrant ainsi une partie des d\u00e9partements fran\u00e7ais de l\u2019Ain et de Haute-Savoie. Enfin, il couvre \u00e9galement une partie du Chablais valaisan et les r\u00e9gions de la Broye et de Gruy\u00e8re dans le canton de Fribourg.</p> <p>Le Panel L\u00e9manique est compos\u00e9 de plusieurs vagues. Au total, cinq vagues comparatives vont avoir lieu entre 2022 et 2026 (trois sur la mobilit\u00e9 et deux sur les habitudes de consommation et le logement). De plus, des vagues uniques sont men\u00e9es, autant sur l'ensemble du p\u00e9rim\u00e8tre (vague PDCn, vague Rythme et Ins\u00e9curit\u00e9) que sur des parties du p\u00e9rim\u00e8tre (vagues loisirs estivaux et hivernaux).</p> <p>Les donn\u00e9es de ces vagues ont \u00e9t\u00e9 r\u00e9colt\u00e9es par FORS, le centre de comp\u00e9tences suisse en sciences sociales, puis trait\u00e9es par le LaSUR. Elles sont aujourd'hui mises \u00e0 disposition pour la recherche ainsi que les partenaires.</p> <p>Ce site a pour vocation de documenter le traitement des donn\u00e9es effectu\u00e9 au LaSUR avant de les publier sur OPAL.</p>"},{"location":"contact/","title":"Contact","text":"<p>Alexander Lepper</p> <p></p> <ul> <li>\ud83d\udce7 alexander.lepper@epfl.ch </li> <li>\ud83c\udf10 Plus d'informations </li> </ul>"},{"location":"ete/","title":"Vague loisirs \u00e9t\u00e9","text":"<p>Cette page documente le preprocessing de la vague loisirs \u00e9t\u00e9 effectu\u00e9 dans le fichier <code>preprocess_loisirs_ete.R</code>.</p>"},{"location":"ete/#fonction-get_section","title":"Fonction <code>get_section</code>","text":"<p>Le but est le m\u00eame que dans la vague 1. N\u00e9anmoins, cette vague poss\u00e9dait des sous-sections, la structure de la fonction est diff\u00e9rente</p> <pre><code>if (num &gt;= 34 &amp;&amp; num &lt; 43) {\n    decimal &lt;- as.numeric(sub(\"^Q[0-9]+\\\\.(\\\\d+).*\", \"\\\\1\", question_code))\n    if (!is.na(decimal)) {\n      return(switch(as.character(decimal),\n                    \"1\" = \"4.1 Aller chez des ami\u00b7es, la famille\",\n                    \"2\" = \"4.2 Restaurants, bars, \u2026\",\n                    \"3\" = \"4.3 Activit\u00e9s culturelles\",\n                    \"4\" = \"4.4 Activit\u00e9 de divertissement et de consommation\",\n                    \"5\" = \"4.5 Activit\u00e9s sportives et de d\u00e9tente en ext\u00e9rieur\",\n                    \"6\" = \"4.6 Sports sur terrain ou en salle\",\n                    \"4. Les loisirs\"\n      ))\n    }\n    return(\"4. Les loisirs\")\n  }\n</code></pre> <p>Les sous-sections 4.1 \u00e0 4.6 sont attribu\u00e9es avec le code ci-dessus, tandis que le reste des sections est attribu\u00e9 avec le code ci-dessous:</p> <pre><code>\n  if (num &gt;= 1 &amp;&amp; num &lt;= 4) return(\"1. L\u2019emploi du temps estival\")\n  if (num &gt;= 5 &amp;&amp; num &lt;= 21) return(\"2. Les courts s\u00e9jours\")\n  if (num &gt;= 22 &amp;&amp; num &lt;= 32) return(\"3. Les excursions\")\n  if (num &gt;= 33 &amp;&amp; num &lt;= 42 || num == 131) return(\"4. Les loisirs\")\n  if (num &gt;= 43 &amp;&amp; num &lt;= 45) return(\"5. Donn\u00e9es personnelles\")\n\n\n  return(NA)\n</code></pre>"},{"location":"ete/#fonction-documentation","title":"Fonction <code>documentation</code>","text":"<p>Similaire \u00e0 la vague 1</p>"},{"location":"ete/#fonction-write_files_questions","title":"Fonction <code>write_files_questions</code>","text":"<p>Similaire \u00e0 la vague 1.</p>"},{"location":"ete/#fonction-write_label_file","title":"Fonction <code>write_label_file</code>","text":"<p>Similaire \u00e0 la vague 1</p>"},{"location":"ete/#fonction-write_file_section","title":"Fonction <code>write_file_section</code>","text":"<p>Similaire \u00e0 la vague 1</p>"},{"location":"ete/#fonction-write_files_participants","title":"Fonction <code>write_files_participants</code>","text":"<p>Similaire \u00e0 la vague 3. Seules les questions <code>Q43</code> (date de naissance) et <code>Q107_V1</code> (genre) ont \u00e9t\u00e9 rajout\u00e9e.</p>"},{"location":"ete/#fonction-write_files_survey_completion","title":"Fonction <code>write_files_survey_completion</code>","text":"<p>Similaire \u00e0 la vague 1</p>"},{"location":"ete/#fonction-write_file_answers","title":"Fonction <code>write_file_answers</code>","text":"<p>Similaire \u00e0 la vague 1</p>"},{"location":"ete/#fonction-main","title":"Fonction <code>main</code>","text":"<p>Similaire \u00e0 la vague 3. Les diff\u00e9rences sont not\u00e9es ci-dessous:</p> <pre><code>data_ete &lt;- data_ete %&gt;%\n  dplyr::rename_with(\n    ~ gsub(\"^_\", \"\", gsub(\"(.*)(latitude|longitude)(.*)\", \"\\\\1\\\\3_\\\\2\", .)),\n    .cols = matches(\"latitude|longitude\")\n  )\n</code></pre> <p>Si les variables contiennent des g\u00e9odonn\u00e9es, la mention latitude ou longitude est d\u00e9plac\u00e9e \u00e0 la fin du nom de la variable.</p> <pre><code>data_ete &lt;- data_ete %&gt;%\n    dplyr::rename_with(\n      ~ gsub(\"^END_(Q[0-9.]+(?:_.*)?)$\", \"\\\\1_END\", .)\n    )\n</code></pre> <p>De m\u00eame pour les variables appartennant \u00e0 la derni\u00e8re section et le suffixe END.</p> <pre><code># Renomme les questions 34 \u00e0 42\n  data_ete &lt;- data_ete %&gt;%\n    dplyr::rename_with(~ sub(\"^x[1-6]_\", \"\", .))\n</code></pre> <p>Les questions 34 \u00e0 42 \u00e9taient nomm\u00e9es <code>x1_Q34_1_1</code>, <code>x4_Q38_4_3</code>, etc. Le pr\u00e9fixe <code>x*_</code> a donc \u00e9t\u00e9 supprim\u00e9 afin de faire commencer le nom de la variable par \"Q\".</p>"},{"location":"geocodage/","title":"G\u00e9ocodage","text":"<p>Cette page est la documentation du fichier <code>Geocodage.R</code>. Dans les donn\u00e9es livr\u00e9es par FORS pour la vague 3, certaines adresses \u00e9taient sous forme de coordonn\u00e9es g\u00e9ographiques (latitude, longitude), tandis que d'autres \u00e9taient sous forme d'adresse postale (e.g. 10 Downing Street, London). Afin d'harmoniser les donn\u00e9es dans la vague 3 et avec les autres vagues, ces adresses postales ont \u00e9t\u00e9 g\u00e9ocod\u00e9es en coordonn\u00e9es \u00e0 l'aide du package <code>tidygeocoder</code>.</p>"},{"location":"geocodage/#fonction-geocoding","title":"Fonction <code>geocoding</code>","text":"<ul> <li>Description: cette fonction transforme une adresse postale en coordonn\u00e9es g\u00e9ographique</li> <li>Input: un string contenant une adresse</li> <li>Output: un string avec les coordonn\u00e9es g\u00e9ographiques en format lat,lng.</li> <li>D\u00e9tail:</li> </ul> <pre><code>if (is.na(addr) || addr == \"\" || addr == \"-998.998,-998.998\" || is_coordinates(addr)) {\n    return(addr)\n</code></pre> <p>V\u00e9rifie que le string n'est pas vide, un NA, une valeure \u00e9quivalente \u00e0 un NA et est bien une adresse \u00e0 l'aide de la fonction <code>is_coordinates</code>.</p> <pre><code>address_df &lt;- data.frame(address = addr, stringsAsFactors = FALSE)\n</code></pre> <p>Transforme l'adresse en dataframe, vu que c'est le format attendu par la fonction <code>geocode</code> du package <code>tidygeocoder</code>.</p> <pre><code>\n        res &lt;- geocode(.tbl = address_df, address = address, method = \"osm\",\n                       lat = latitude, long = longitude, limit = 1, verbose = FALSE)\n        Sys.sleep(1)\n        res\n      },\n      error = function(e) {\n        message(\"Error during geocoding: \", e$message)\n        return(NULL)\n      }\n</code></pre> <p>La fonction <code>geocode</code> est appliqu\u00e9e sur l'adresse. Une pause d'une seconde est forc\u00e9e entre chaque requ\u00eate pour respecter les limites de demande d'OpenStreetMap. Un message d'erreur est g\u00e9n\u00e9r\u00e9 si n\u00e9cessaire.</p> <pre><code>if (is.data.frame(result) &amp;&amp; !is.na(result$latitude)) {\n      return(paste(result$latitude, result$longitude, sep = \",\"))\n    } else {\n      return(NA_character_)\n    }\n</code></pre> <p>Si le r\u00e9sultat est valide, il est format\u00e9 sous le format lat,lng est retourn\u00e9. Autrement, un NA est retourn\u00e9.</p>"},{"location":"geocodage/#fonction-main","title":"Fonction <code>main</code>","text":"<pre><code>raw_data &lt;- \"base_ponderee_panel_vague_3_mobilite_clean.sav\"\ngeodata &lt;- \"Recodage-adresse.csv\"\n\nwave3_data &lt;- haven::read_sav(file.path(folder, raw_data))\nexisting_coords &lt;- readr::read_tsv(file.path(folder, geodata), show_col_types = FALSE)\n</code></pre> <p>Les donn\u00e9es brutes de la vague 3 sont charg\u00e9es, ainsi certaines donn\u00e9es ayant d\u00e9j\u00e0 \u00e9t\u00e9 g\u00e9ocod\u00e9es au pr\u00e9alable et enregistr\u00e9es dans le fichier <code>Recodage-adresse.csv</code>.</p> <pre><code>cols_to_process &lt;- c(\"W1_q14\", \"Q14_regroup\", \"Q43\", \"Q48\", \"W1_q48\",\n                       \"Q48_regroup\", \"Q50\", \"W1_q50\", \"Q50_regroup\",\n                       \"Q51\", \"W1_q51\", \"Q51_regroup\")\n\ngeolocalised_columns &lt;- wave3_data %&gt;%\n  select(IDNO, all_of(cols_to_process)) %&gt;%\n  mutate(across(-IDNO, as.character))\n</code></pre> <p>Les colonnes \u00e0 g\u00e9ocoder sont s\u00e9lectionn\u00e9es et transform\u00e9es en string.</p> <pre><code>for (col in cols_to_process) {\n  geolocalised_columns[[col]] &lt;- sapply(geolocalised_columns[[col]], extract_lat_lng)\n  }\n</code></pre> <p>Le formatage des coordonn\u00e9es g\u00e9ographiques livr\u00e9es dans la vague 3 par FORS \u00e9tant sp\u00e9cial, ces donn\u00e9es sont reformat\u00e9es de la forme lat, lng \u00e0 l'aide de extract_lat_lng.</p> <pre><code>for (col in cols_to_process) {\n  output_file &lt;- file.path(output_folder, paste0(\"geocoded_\", col, \".rds\"))\n\n  if (file.exists(output_file)) {\n    message(\"Skipping already processed column: \", col)\n    geolocalised_columns[[col]] &lt;- readRDS(output_file)\n  } else {\n    message(\"Geocoding column: \", col)\n    geolocalised_columns[[col]] &lt;- map_chr(geolocalised_columns[[col]], geocoding)\n    saveRDS(geolocalised_columns[[col]], output_file)\n  }\n}\n</code></pre> <p>Les donn\u00e9es sont ensuite g\u00e9ocod\u00e9es. Comme le code \u00e9tait long \u00e0 tourner, il a \u00e9t\u00e9 lanc\u00e9 en plusieurs fois. C'est pourquoi, d\u00e8s qu'une colonne \u00e9tait g\u00e9ocod\u00e9e, elle est enregistr\u00e9es en tant que .rds. Avant de lancer le g\u00e9ocodage, on v\u00e9rifie qu'un fichier .rds n'existe pas d\u00e9j\u00e0, afin de ne pas refaire tourner le code inutilement.</p> <pre><code>existing_coords &lt;- existing_coords %&gt;%\n    mutate(lat_lng = paste(Q14_R_lat, Q14_R_lng, sep = \",\"))\n\n  geolocalised_columns &lt;- geolocalised_columns %&gt;%\n    left_join(existing_coords %&gt;% select(IDNO, lat_lng), by = \"IDNO\")\n\n\n  cols &lt;- colnames(geolocalised_columns)\n  cols &lt;- cols[cols != \"lat_lng\"]\n\n  new_order &lt;- c(cols[1], \"lat_lng\", cols[-1])\n  geolocalised_columns &lt;- geolocalised_columns[, new_order]\n\n  readr::write_csv(geolocalised_columns, file.path(output_folder, \"geolocalised_data.csv\"))\n</code></pre> <p>Les coordonn\u00e9es contenue dans le fichier <code>Recodage-adresse.csv</code> sont reformat\u00e9es avant d'\u00eatre ajout\u00e9es au fichier avec toutes les coordonn\u00e9es nouvellement obtenues. Enfin, l'ensemble des coordonn\u00e9es est sauvegard\u00e9e dans un fichier csv.</p>"},{"location":"hiver/","title":"Vagues loisirs hiver","text":"<p>Cette page documente le preprocessing de la vague loisirs hiver effectu\u00e9 dans le fichier <code>preprocess_loisirs_hiver.R</code>.</p>"},{"location":"hiver/#fonction-get_section","title":"Fonction <code>get_section</code>","text":"<p>Similaire \u00e0 la vague \u00e9t\u00e9</p>"},{"location":"hiver/#fonction-documentation","title":"Fonction <code>documentation</code>","text":"<p>Similaire \u00e0 la vague \u00e9t\u00e9</p>"},{"location":"hiver/#fonction-write_label_file","title":"Fonction <code>write_label_file</code>","text":"<p>Similaire \u00e0 la vague \u00e9t\u00e9</p>"},{"location":"hiver/#fonction-write_file_section","title":"Fonction <code>write_file_section</code>","text":"<p>Similaire \u00e0 la vague \u00e9t\u00e9</p>"},{"location":"hiver/#fonction-write_files_questions","title":"Fonction <code>write_files_questions</code>","text":"<p>Similaire \u00e0 la vague \u00e9t\u00e9</p>"},{"location":"hiver/#fonction-write_files_survey_completion","title":"Fonction <code>write_files_survey_completion</code>","text":"<p>Similaire \u00e0 la vague \u00e9t\u00e9</p>"},{"location":"hiver/#fonction-write_file_answers","title":"Fonction <code>write_file_answers</code>","text":"<p>Similaire \u00e0 la vague \u00e9t\u00e9</p>"},{"location":"hiver/#fonction-main","title":"Fonction <code>main</code>","text":"<p>Similaire \u00e0 la vague \u00e9t\u00e9. Seules quelques questions ont d\u00fb \u00eatre renomm\u00e9e \u00e0 la main pour \u00eatre au format <code>Q*</code>:</p> <pre><code># Rajoute le \"Q\" devant le num de la question s'il manque\n  cols_a_renommer &lt;- c(\"34.4\", \"35.4\", \"36.4\", \"41.4\", \"34.5\", \"35.5\")\n  names(data_hiver)[names(data_hiver) %in% cols_a_renommer] &lt;- paste0(\"Q\", cols_a_renommer)\n\n  data_hiver &lt;- data_hiver %&gt;%\n    dplyr::rename_with(~ paste0(\"Q\", .), \n                       .cols = dplyr::starts_with(\"37.4_1_\"))\n</code></pre>"},{"location":"pdcn/","title":"Vague acceptabilit\u00e9 sociale de mesures d'am\u00e9nagement du territoire","text":"<p>Cette page documente le preprocessing de la vague sur l'am\u00e9nagement du territoire effectu\u00e9 dans le fichier <code>preprocess_pdcn.R</code>. L'abbr\u00e9viation PDCn r\u00e9f\u00e9re au Plan Directeur Cantonal.</p>"},{"location":"pdcn/#fonction-get_section","title":"Fonction <code>get_section</code>","text":"<p>Similaire \u00e0 la vague \u00e9t\u00e9</p>"},{"location":"pdcn/#fonction-documentation","title":"Fonction <code>documentation</code>","text":"<p>Similaire \u00e0 la vague \u00e9t\u00e9</p>"},{"location":"pdcn/#fonction-write_file_section","title":"Fonction <code>write_file_section</code>","text":"<p>Similaire \u00e0 la vague \u00e9t\u00e9</p>"},{"location":"pdcn/#fonction-write_files_questions","title":"Fonction <code>write_files_questions</code>","text":"<p>Similaire \u00e0 la vague \u00e9t\u00e9</p>"},{"location":"pdcn/#fonction-write_label_file","title":"Fonction <code>write_label_file</code>","text":"<p>Similaire \u00e0 la vague \u00e9t\u00e9</p>"},{"location":"pdcn/#fonction-write_files_survey_completion","title":"Fonction <code>write_files_survey_completion</code>","text":"<p>Similaire \u00e0 la vague 3</p>"},{"location":"pdcn/#fonction-write_files_survey_completion_1","title":"Fonction <code>write_files_survey_completion</code>","text":"<p>Similaire \u00e0 la vague 3. Les colonnes avec les poids pour la pond\u00e9ration ont \u00e9t\u00e9 rajout\u00e9s:</p> <pre><code>ponderation_colnames &lt;- names(data)[startsWith(names(data), \"wgt\")]\n</code></pre>"},{"location":"pdcn/#fonction-write_file_answers","title":"Fonction <code>write_file_answers</code>","text":"<p>Similaire \u00e0 la vague 3</p>"},{"location":"pdcn/#fonction-main","title":"Fonction <code>main</code>","text":"<p>Similaire \u00e0 la vague 3. Le drive du LaSUR poss\u00e9dait encore un fichier rassemblant des poids pour la pond\u00e9ration socio-\u00e9conomique. Ceux-ci ont dont \u00e9t\u00e9 rajout\u00e9s aux donn\u00e9es brutes:</p> <pre><code>ponderation &lt;- read.csv(file.path(folder, raw_ponderation))\n\n  col_ponderation &lt;- c(\"IDNO\", \"wgt_cant\", \"wgt_agg\", \"wgt_cant_trim\", \"wgt_agg_trim\")\n  weights &lt;- ponderation %&gt;% dplyr::select(dplyr::all_of(col_ponderation))\n\n  data_pdcn &lt;- data_pdcn %&gt;% dplyr::left_join(weights, by = \"IDNO\")\n</code></pre>"},{"location":"rythme/","title":"Vague rythmes et temporalit\u00e9s de mobilit\u00e9","text":"<p>Cette page documente le preprocessing de la vague rythmes effectu\u00e9 dans le fichier <code>preprocess_rythme.R</code>.</p>"},{"location":"rythme/#fonction-get_section","title":"Fonction <code>get_section</code>","text":"<p>Similaire \u00e0 la vague 1</p>"},{"location":"rythme/#fonction-documentation","title":"Fonction <code>documentation</code>","text":"<p>Similaire \u00e0 la vague 3</p>"},{"location":"rythme/#fonction-write_label_file","title":"Fonction <code>write_label_file</code>","text":"<p>Similaire \u00e0 la vague 3</p>"},{"location":"rythme/#fonction-write_file_section","title":"Fonction <code>write_file_section</code>","text":"<p>Similaire \u00e0 la vague 3</p>"},{"location":"rythme/#fonction-write_files_questions","title":"Fonction <code>write_files_questions</code>","text":"<p>Similaire \u00e0 la vague 3</p>"},{"location":"rythme/#fonction-write_files_survey_completion","title":"Fonction <code>write_files_survey_completion</code>","text":"<p>Similaire \u00e0 la vague 3</p>"},{"location":"rythme/#fonction-write_files_participants","title":"Fonction <code>write_files_participants</code>","text":"<p>Similaire \u00e0 la vague 3</p>"},{"location":"rythme/#fonction-write_file_answers","title":"Fonction <code>write_file_answers</code>","text":"<p>Similaire \u00e0 la vague 3</p>"},{"location":"rythme/#fonction-main","title":"Fonction <code>main</code>","text":"<p>Similaire \u00e0 la vague 3. Certaines questions sont renomm\u00e9es afin de mieux pouvoir les assigner \u00e0 leur section. Ainsi, elles sont renomm\u00e9es selon le format <code>PX_Q*</code>, avec <code>X</code> le num\u00e9ro de la section:</p> <pre><code>cols_P3 &lt;- c(\"RecrutementRythmes\", \"CommuneCibleRythmes\", \"RecrutementInsecurite\", \"CommuneCibleInsecurite\")\n   cols_P0 &lt;- c(\"date_naissance\", \"genre\", \"permis_1\", \"permis_2\", \"permis_3\", \"permis_4\", \"statut_pro\")\n\n   data_rythme &lt;- data_rythme %&gt;%\n     dplyr::rename_with(~ paste0(\"P4_\", .x), .cols = dplyr::matches(\"^(SatisfQ|Rem)\")) %&gt;%\n     dplyr::rename_with(~ paste0(\"P3_\", .x), dplyr::all_of(cols_P3)) %&gt;%\n     dplyr::rename_with(~ paste0(\"P0_\", .x), dplyr::all_of(cols_P0))\n</code></pre>"},{"location":"utils/","title":"Fonction helpers","text":"<p>Cette page documente les fonctions du fichier <code>utils.R</code>.</p>"},{"location":"utils/#fonction-labels_to_string","title":"Fonction <code>labels_to_string</code>","text":"<p>Cette fonction reprend les labels obtenus gr\u00e2ce \u00e0 la fonction <code>get_labels</code> et les transforme en un string. Le format vis\u00e9 est <code>1: texte_label_1, 2: texte_label_2, etc...</code>.</p>"},{"location":"utils/#fonction-zap_all","title":"Fonction <code>zap_all</code>","text":"<p>Applique toutes les fonctions du package <code>haven::zap_*</code> except\u00e9 <code>zap_empty</code>.</p>"},{"location":"utils/#fonction-get_labels","title":"Fonction <code>get_labels</code>","text":"<p>Cette fonction extrait les lables des variables:</p> <pre><code>x &lt;- x |&gt;\n    dplyr::select(tidyselect::where(haven::is.labelled))\n</code></pre> <p>S\u00e9lectionne les colonnes labellis\u00e9es du dataframe pass\u00e9 en argument</p> <pre><code>if (ncol(x) == 0) {\n    return(tibble::tibble(\n      \"{names_to}\" := character(),\n      \"{name}\" = character(), \"{value}\" = integer()\n    ))\n  }\n</code></pre> <p>Retourne un tibble vide si aucune colonne labellis\u00e9es n'existe</p> <pre><code>label_list &lt;- purrr::imap(\n    x,\n    ~ tibble::enframe(attr(.x, \"labels\"), name = name, value = value) |&gt;\n      dplyr::mutate(\n        !!name := stringr::str_squish(\n          stringr::str_replace_all(.data[[name]], \"(\\n|\\t)\", \" \")\n          ),\n        !!names_to := .y\n      ) |&gt;\n      dplyr::select(!!names_to, !!name, !!value)\n  )\n</code></pre> <p>R\u00e9cup\u00e8re les labels, supprimes les retour \u00e0 la ligne et les retours chariot, et les organise dans un tibble</p> <pre><code>value_types &lt;- purrr::map_chr(label_list, ~ typeof(.x[[value]]))\n  unique_types &lt;- unique(value_types)\n\n  if (length(unique_types) &gt; 1) {\n    label_list &lt;- purrr::map(label_list, ~ dplyr::mutate(.x, !!value := as.character(.data[[value]])))\n  }\n</code></pre> <p>Transforme toutes les valeurs dans la colonne <code>value</code> en string si plusieurs types existent, afin de limiter les erreurs</p> <pre><code>dplyr::bind_rows(label_list)\n</code></pre> <p>Concat\u00e8ne toutes les lignes des tibble en un seul tibble</p>"},{"location":"utils/#fonction-remove_escapeseqs","title":"Fonction <code>remove_escapeseqs</code>","text":"<p>Supprime tout les retours \u00e0 la ligne et les retours charriot des cha\u00eenes de caract\u00e8re du dataframe pass\u00e9 en argument</p>"},{"location":"utils/#fonction-pivot_responses","title":"Fonction <code>pivot_responses</code>","text":"<p>Pivote le dataframe pass\u00e9 en argument en version longue avec <code>pivot_longer</code> et supprimes les NA. Ne s\u00e9lectionne que les cha\u00eenes de caract\u00e8re ou que les valeurs num\u00e9riques, selon l'argument pass\u00e9.</p>"},{"location":"utils/#fonction-remove_whitespace","title":"Fonction <code>remove_whitespace</code>","text":"<p>Supprime les espaces du string pass\u00e9 en argument</p>"},{"location":"utils/#fonction-extract_lat_lng","title":"Fonction <code>extract_lat_lng</code>","text":"<p>Extrait les coordonn\u00e9es du json-string pass\u00e9 en argument et les rend en format lat, lng. Utilis\u00e9 pour reformater les coordonn\u00e9es livr\u00e9es par FORS.</p>"},{"location":"utils/#fonction-is_coordinates","title":"Fonction <code>is_coordinates</code>","text":"<p>D\u00e9tecte si la valeur pass\u00e9e en argument est une coordonn\u00e9e en format lat, lng.</p>"},{"location":"utils/#fonction-double_to_integer","title":"Fonction <code>double_to_integer</code>","text":"<p>Transforme les <code>&lt;double&gt;</code> du dataframe pass\u00e9 en argument en <code>&lt;integer&gt;</code>, tout en gardant les labels des valeurs. Utilis\u00e9 afin de permettre \u00e0 OPAL de faire tourner ses analyses.</p>"},{"location":"wave1/","title":"Vague 1: Mobilit\u00e9 I","text":"<p>Cette page documente le preprocessing de la premi\u00e8re vague du Panel L\u00e9manique effectu\u00e9 dans le fichier <code>wave1-alexander.R</code>.</p>"},{"location":"wave1/#fonction-recoder_adjectifs","title":"Fonction <code>recoder_adjectifs</code>","text":"<ul> <li>Description: recode les questions 97 \u00e0 100 afin de les harmoniser avec les m\u00eames questions de la vague 3. Retourne pour chaque question trois variables (e.g.: <code>Q97_1</code>, <code>Q97_2</code>et <code>Q97_3</code>) avec les adjectifs labell\u00e9s de 1 \u00e0 24</li> <li>Input: les donn\u00e9es brutes de la vague 1, le suffixe, indiquant le mode de transport dont la question traite (e.g. <code>voiture</code>), ainsi que le nom complet de la questions (e.g.: <code>Q97</code>)</li> <li>Output: les donn\u00e9es brutes de la vague 1 avec les questions 97 \u00e0 100 recod\u00e9es</li> <li>D\u00e9tail:</li> </ul> <pre><code>pattern &lt;- paste0(\"_\", suffixe, \"$\")\ntexte_col &lt;- paste0(\"Autre_TEXTE_\", suffixe)\nautre_col &lt;- paste0(\"Autre_\", suffixe)\npossible_cols &lt;- names(data)[stringr::str_detect(names(data), pattern)]\nadjectif_cols &lt;- possible_cols[!(possible_cols %in% c(texte_col, autre_col))]\n</code></pre> <p>D\u00e9tecte toutes les colonnes traitant d'un mode de transport, et ne garde que les colonnes avec des valeurs num\u00e9riques.</p> <pre><code>long_data &lt;- data %&gt;%\n  dplyr::select(IDNO, dplyr::all_of(adjectif_cols)) %&gt;%\n  tidyr::pivot_longer(\n    cols = -IDNO,\n    names_to = \"adjectif_var\",\n    values_to = \"selected\"\n  ) %&gt;%\n  dplyr::filter(selected == 1) %&gt;%\n  dplyr::mutate(adjectif = stringr::str_remove(adjectif_var, paste0(\"_\", suffixe)))\n</code></pre> <p>Passage en format \u00e0 l'aide de la fonction <code>pivot_longer</code> en ne gardant que les r\u00e9ponses coch\u00e9es et suppression du suffixe du nom de la variable.</p> <pre><code>dictionnaire &lt;- long_data %&gt;%\n  dplyr::distinct(adjectif) %&gt;%\n  dplyr::arrange(adjectif) %&gt;%\n  dplyr::mutate(code = dplyr::row_number())\n</code></pre> <p>Cr\u00e9ation du dictionnaire des adjectifs</p> <pre><code>coded_data &lt;- long_data %&gt;%\n  dplyr::left_join(dictionnaire, by = \"adjectif\") %&gt;%\n  dplyr::select(IDNO, code)\n\ngrouped &lt;- coded_data %&gt;%\n  dplyr::group_by(IDNO) %&gt;%\n  dplyr::summarise(codes = list(sort(code)), .groups = \"drop\")\n</code></pre> <p>Cr\u00e9e une liste des adjectifs choisis par chaque participant\u00b7e</p> <pre><code>wide_data &lt;- grouped %&gt;%\n  tidyr::unnest_wider(codes, names_sep = \"_\") %&gt;%\n  dplyr::rename_with(~ paste0(question_nom, \"_\", seq_along(.)), starts_with(\"codes_\"))\n</code></pre> <p>Retour en format large, renommage des colonnes en <code>Q97_1</code>, <code>Q97_2</code>, etc ...</p> <pre><code>adjective_list &lt;- dictionnaire$adjectif[!is.na(dictionnaire$adjectif) &amp; dictionnaire$adjectif != \"\"]\nlabels &lt;- setNames(seq_along(adjective_list), adjective_list)\nwide_data &lt;- wide_data %&gt;%\n  dplyr::mutate(\n    dplyr::across(\n      -IDNO,\n      ~ haven::labelled(.x, labels)\n    )\n  )\n</code></pre> <p>Les colonnes sont labellis\u00e9es</p> <pre><code>data_final &lt;- data %&gt;%\n  dplyr::select(-dplyr::all_of(adjectif_cols)) %&gt;%\n  dplyr::select(-dplyr::all_of(paste0(\"Autre_\", suffixe))) %&gt;%\n  dplyr::rename(!!paste0(question_nom, \"_TEXTE\") := dplyr::all_of(texte_col)) %&gt;%\n  dplyr::left_join(wide_data, by = \"IDNO\")\n</code></pre> <p>Les nouvelles colonnes sont rajout\u00e9es au database de base, les anciennes sont supprim\u00e9es et les colonnes textes sont renomm\u00e9es en <code>Q97_TEXTE</code>, <code>Q98_TEXTE</code>, etc ...</p>"},{"location":"wave1/#fonction-get_section","title":"Fonction <code>get_section</code>","text":"<ul> <li>Description: retourne la section du questionnaire dont fait partie une questions</li> <li>Input: le num\u00e9ro de la question</li> <li>Output: le nom de la section</li> </ul>"},{"location":"wave1/#fonction-documentation","title":"Fonction <code>documentation</code>","text":"<ul> <li>Description: permet d'obtenir une documentation de toutes les variables dans la vague 1</li> <li>Input: les donn\u00e9es brutes de la vague 1</li> <li>Output: un fichier csv avec le nom de la variable, le texte de la variable et les labels de la variable</li> </ul>"},{"location":"wave1/#fonction-write_files_participants","title":"Fonction <code>write_files_participants</code>","text":"<ul> <li>Description: permet d'obtenir toutes les informations relatives aux particpant\u00b7es de la vague 1</li> <li>Input: les donn\u00e9es brutes de la vague 1</li> <li>Output: un fichier csv avec une ligne par participant\u00b7e et les informations relatives aux participant\u00b7es de la vague 1, ainsi qu'un fichier labels d\u00e9taillant les labels des variables dans le premier fichier</li> </ul>"},{"location":"wave1/#fonction-write_files_questions","title":"Fonction <code>write_files_questions</code>","text":"<ul> <li>Description: permet de lister les questions pos\u00e9es aux participant\u00b7es dans cette vague</li> <li>Input: les donn\u00e9es brutes de la vague 1</li> <li>Output: un fichier csv contenant les variables des questions, le texte des questions et leur section dans le questionnaire (obtenue avec la fonction get_section, voir <code>get_section</code>), ainsi qu'un fichier labels, d\u00e9taillant les labels des questions</li> </ul>"},{"location":"wave1/#fonction-write_files_survey_completion","title":"Fonction <code>write_files_survey_completion</code>","text":"<ul> <li>Description: renvoie les m\u00e9tadonn\u00e9es de l'enqu\u00eate</li> <li>Input: les donn\u00e9es brutes de la vague 1</li> <li>Output: un fichier csv contenant pour chaque participant\u00b7e la liste des m\u00e9tadonn\u00e9es</li> </ul>"},{"location":"wave1/#fonction-write_label_file","title":"Fonction <code>write_label_file</code>","text":"<ul> <li>Description: permet d'\u00e9crire tout les csv labels. Retire les labels pour les colonnes indiqu\u00e9es \u00e0 l'aide de la fonction <code>get_labels</code></li> <li>Input: les donn\u00e9es brutes de la vague 1, les colonnes dont il faut retirer les labels, et le nom final du fichier csv</li> <li>Output: un fichier csv contenant les labels des colonnes indiqu\u00e9es</li> </ul>"},{"location":"wave1/#fonction-write_file_section","title":"Fonction <code>write_file_section</code>","text":"<ul> <li>Description: permet d'obtenir les sections du questionnaire de la vague 1</li> <li>Input: aucun</li> <li>Output: un fichier csv contenant les sections du questionnaire</li> </ul>"},{"location":"wave1/#fonction-write_file_answers","title":"Fonction <code>write_file_answers</code>","text":"<ul> <li>Description: permet d'obtenir les r\u00e9ponses aux questions par les participantes. Affiche une r\u00e9ponse par participant\u00b7es par ligne.</li> <li>Input: les donn\u00e9es brutes de la vague 1</li> <li>Output: un fichier csv avec une r\u00e9ponse par question et par participant\u00b7e par ligne</li> <li>D\u00e9tail:</li> </ul> <pre><code>participants_colnames &lt;- c(\"group\",\"pays\",\"gp_age_source\",\"numero_insee\",\"numero_ofs\",\"CP_source\",\"Localit\u00e9_source\")\n  extra_colnames &lt;- c(\"wgt_socio\",  \"wgt_cant_trim\",    \"wgt_agg_trim\", \"wgt_cant_trim_gps\",    \"wgt_agg_trim_gps\", \"wgt_cant_trim_v2\", \"wgt_agg_trim_v2\")\n  responses &lt;- data |&gt;\n    dplyr::select(\n      -all_of(c(participants_colnames, extra_colnames))\n    ) |&gt;\n    zap_all()\n</code></pre> <p>Ne s\u00e9lectionne que les colonnes avec les questions, et applique tout les fonctions de <code>haven::zap_*</code> avec <code>zap_all</code></p> <pre><code>responses &lt;- responses |&gt; \n    dplyr::mutate(dplyr::across(tidyselect::where(is.character), ~ remove_whitespace(.x))) |&gt;\n    dplyr::mutate(dplyr::across(tidyselect::everything(), ~ readr::parse_guess(as.character(.x))))\n</code></pre> <p>Supprime tout les espaces au d\u00e9but d'une cha\u00eene de caract\u00e8re et cherche \u00e0 obtenir le type de donn\u00e9es</p> <pre><code>response_texts &lt;- pivot_responses()\nresponse_values &lt;- pivot_responses()\n</code></pre> <p>Pivote les tableaux</p>"},{"location":"wave1/#fonction-main","title":"Fonction <code>main</code>","text":"<ul> <li>Description: nettoye les donn\u00e9es et obtiens tout les csv gr\u00e2ce aux fonctions d\u00e9crites plus haut</li> <li>Input: aucun</li> <li>Output: aucun</li> <li>D\u00e9tail:</li> </ul> <pre><code>get_data_folder &lt;- function() {\n    os &lt;- Sys.info()[[\"sysname\"]]\n\n    if (os == \"Linux\") {\n      return(\"/mnt/lasur/\")  \n    } else if (os == \"Darwin\") {\n      return(\"/Volumes/LASUR/\")  \n    } else if (os == \"Windows\") {\n      return(\"//enac1files.epfl.ch/LASUR\")  \n    } else {\n      stop(\"Unsupported OS\")\n    }\n  }\n</code></pre> <p>D\u00e9tecte l'OS de l'utilisateur et essaye d'obtenir l'emplacement du drive lasur</p> <pre><code># Suppress participants where data has to be erased\n  id_suppress &lt;- c(\"CH21089\", \"FR3456\", \"CH18003\")\n  wave1_data &lt;- wave1_data %&gt;% \n    dplyr::filter(!IDNO %in% id_suppress)\n</code></pre> <p>Supprime les participant\u00b7es ayant demand\u00e9 la suppression de leurs donn\u00e9es</p> <pre><code>  wave1_data &lt;- wave1_data[wave1_data$Participe == 1,]\n</code></pre> <p>Ne garde que les participant\u00b7es ayant compl\u00e9t\u00e9 enti\u00e8rement le questionnaire</p> <pre><code>  wave1_data &lt;- recoder_adjectifs(wave1_data, suffixe = \"voiture\", question_nom = \"Q97\")\n  wave1_data &lt;- recoder_adjectifs(wave1_data, suffixe = \"train\", question_nom = \"Q98\")\n  wave1_data &lt;- recoder_adjectifs(wave1_data, suffixe = \"autresTPs\", question_nom = \"Q99\")\n  wave1_data &lt;- recoder_adjectifs(wave1_data, suffixe = \"velo\", question_nom = \"Q100\")\n\n  labels_questions &lt;- list(\n    Q97 = \"Pouvez-vous citer trois adjectifs qui vous paraissent les plus adapt\u00e9s pour qualifier la voiture ?\",\n    Q98 = \"Pouvez-vous citer trois adjectifs qui vous paraissent les plus adapt\u00e9s pour qualifier le train (y compris L\u00e9man Express) ?\",\n    Q99 = \"Pouvez-vous citer trois adjectifs qui vous paraissent les plus adapt\u00e9s pour qualifier les autres transports publics (m\u00e9tro, tram, bus) ?\",\n    Q100 = \"Pouvez-vous citer trois adjectifs qui vous paraissent les plus adapt\u00e9s pour qualifier le v\u00e9lo (conventionnel ou \u00e9lectrique) ?\"\n  )\n\n  # Applique les labels aux questions 97 \u00e0 100\n  for (q in names(labels_questions)) {\n    vars &lt;- grep(paste0(\"^\", q, \"_\\\\d+$\"), names(wave1_data), value = TRUE)\n    for (v in vars) {\n      attr(wave1_data[[v]], \"label\") &lt;- labels_questions[[q]]\n    }\n\n    texte_col &lt;- paste0(q, \"_TEXTE\")\n    if (texte_col %in% names(wave1_data)) {\n      attr(wave1_data[[texte_col]], \"label\") &lt;- paste0(labels_questions[[q]], \" - TEXTE\")\n    }\n  }\n</code></pre> <p>Recode les questions 97 \u00e0 100 pour qu'elle soient semblable au question 97 \u00e0 100 dans la vague 3 en utilisant la fonction <code>recoder_adjectifs</code> (voir adjectifs).</p> <pre><code>  wave1_data &lt;- wave1_data |&gt;\n    dplyr::rename(\n      participant_code = IDNO,\n      pays = Pays,\n      group = Groupe,\n      gp_age_source = GP_Age_source,\n      numero_insee = Num\u00e9ro_INSEE,\n      numero_ofs = Num\u00e9ro_OFS,\n      date_naissance = Q106,\n      genre = Q107,\n      Q31_jour = jourQ31,\n      check_genre = Checksex,\n      check_age = checkage\n    )\n\n  names(wave1_data) &lt;- sub(\"^satisfaction\", \"Q130_satisfaction\", names(wave1_data))\n  names(wave1_data) &lt;- sub(\"^latitude_(.*)\", \"\\\\1_latitude\", names(wave1_data))\n  names(wave1_data) &lt;- sub(\"^longitude_(.*)\", \"\\\\1_longitude\", names(wave1_data))\n</code></pre> <p>Renomme plusieurs variables afin d'harmoniser le nom de certaines variables r\u00e9currentes entre les vagues et afin que toutes les variables de questions commencent par \"Q\".</p> <pre><code># Recodage de Q41 pour qu'elle match la W3\n  q41_label &lt;- attr(wave1_data$Q41, \"label\")\n  vals &lt;- as.integer(wave1_data$Q41)\n  vals_recoded &lt;- 8 - vals\n\n  old_labels &lt;- attr(wave1_data$Q41, \"labels\")\n  new_labels &lt;- setNames(8 - as.integer(old_labels), names(old_labels))\n  new_labels &lt;- new_labels[order(new_labels)]\n\n  wave1_data$Q41 &lt;- haven::labelled(vals_recoded, new_labels)\n  attr(wave1_data$Q41, \"label\") &lt;- q41_label\n</code></pre> <p>La question 41 ayant \u00e9t\u00e9 cod\u00e9e diff\u00e9remment par FORS entre la W1 et la W3, elle a \u00e9t\u00e9 recod\u00e9e afin d'\u00eatre harmonis\u00e9e entre les deux vagues</p>"},{"location":"wave1/#tableau-1-recodage-de-q41","title":"Tableau 1 \u2013 Recodage de Q41","text":"R\u00e9ponses Ancien labellage Nouveau labellage 7 jours par semaine 1 7 6 jours par semaine 2 6 5 jours par semaine 3 5 4 jours par semaine 4 4 3 jours par semaine 5 3 2 jours par semaine 6 2 1 jour par semaine 7 1 Moins d\u2019un jour par semaine 8 0 <pre><code># Recodage de Q86 pour qu'elle match la W3\n  for (var in c(\"Q86_1\", \"Q86_2\", \"Q86_3\")) {\n    var_label &lt;- attr(wave1_data[[var]], \"label\")\n\n    old_labels &lt;- attr(wave1_data[[var]], \"labels\")\n    new_labels &lt;- setNames(as.integer(old_labels) - 1, names(old_labels))\n\n    new_values &lt;- as.integer(wave1_data[[var]]) - 1\n    wave1_data[[var]] &lt;- haven::labelled(new_values, new_labels)\n\n    attr(wave1_data[[var]], \"label\") &lt;- var_label\n  }\n</code></pre> <p>La m\u00eame chose a eu lieu avec la Q86 qu'avec la Q41. </p>"},{"location":"wave1/#tableau-2-recodage-de-q86","title":"Tableau 2 \u2013 Recodage de Q86","text":"R\u00e9ponses Ancien labellage Nouveau labellage Aucun-e 1 0 1 2 1 2 3 2 3 4 3 4 5 4 5 6 5 6 7 6 7 8 7 8 9 8 9 10 9 10+ 11 10 <pre><code>if (!dir.exists(here::here(\"data/wave1\"))) {\n    dir.create(here::here(\"data/wave1\"), recursive = TRUE)\n  }\n</code></pre> <p>Cr\u00e9ation du dossier <code>data/wave1</code> o\u00f9 sont enregistr\u00e9s les fichiers csv.</p> <pre><code>  doubles_to_convert &lt;- grep(\"^Q|^(genre|date_naissance)$\", names(wave1_data), value = TRUE)\n  wave1_data[doubles_to_convert] &lt;- double_to_integer(wave1_data[doubles_to_convert])\n</code></pre> <p>Certaines variables \u00e9taient des <code>&lt;double&gt;</code> alors qu'en r\u00e9alit\u00e9, elles ne contenaient que des <code>&lt;integer&gt;</code>. Afin de permettre \u00e0 OPAL d'assigner le bon type \u00e0 chaque variable et d'ex\u00e9cuter ses analyses sans fautes, ces colonnes ont \u00e9t\u00e9 transform\u00e9es en <code>&lt;integer&gt;</code>.</p>"},{"location":"wave2/","title":"Vague 2: Consommation I","text":"<p>Cette page documente le preprocessing de la deuxi\u00e8me vague du Panel L\u00e9manique effectu\u00e9 dans le fichier <code>preprocessing-wave2.R</code>.</p> <pre><code>wave2_data &lt;- haven::read_sav(\n  file.path(\n    folder, \"EPFL Panel L\u00c7manique Vague 2 _FINAL_EPFL.sav\"\n  )\n)\n\n# Suppress participants where data has to be erased\nid_suppress &lt;- c(\"CH21089\", \"FR3456\", \"CH18003\")\nwave2_data &lt;- wave2_data %&gt;% \n  dplyr::filter(!IDNO %in% id_suppress)\n\nwave2_data &lt;- wave2_data[wave2_data$Particip_v2 == 1,]\n</code></pre> <p>Les donn\u00e9es brutes sont lues depuis le drive LaSUR. Les participant\u00b7es ayant demand\u00e9s \u00e0 ce que leurs donn\u00e9es soient supprim\u00e9es sont effac\u00e9\u00b7es par s\u00e9curit\u00e9, puis seules les personnes ayant rempli enti\u00e8rement le questionnaire sont gard\u00e9es.</p> <pre><code>names(wave2_data) &lt;- janitor::make_clean_names(names(wave2_data), case = \"snake\", ascii = TRUE)\n\n# The names of four columns are slightly different in the database, so we change them here\nwave2_data &lt;- wave2_data |&gt;\n  dplyr::rename(\n    participant_code = idno,\n    group = groupe,\n    count_miss1 = countmiss1,\n    count_miss2 = countmiss2,\n    numero_insee = insee,\n    numero_ofs = ofs\n  )\n</code></pre> <p>Les noms des colonnes sont harmonis\u00e9s avec le package <code>janitor</code> et certaines colonnes sont renomm\u00e9es.</p> <pre><code># Columns to be included in the participants file. This is currently more liberal than the table\n# definition\nparticipants_colnames &lt;- c(\n  \"participant_code\", \"pays\", \"group\", \"gp_age_source\", \"numero_insee\", \"numero_ofs\", \"weight\",\n  \"titre_source\", \"cp_source\", \"localite_source\", \"titre_actuel\", \"cp_actuel\", \"localite_actuel\", \"code_raison_contact_1_v2\",\n  \"code_raison_contact_2_v2\", \"code_raison_contact_3_v2\", \"particip_v2\"\n)\n\n# Columns to be included in the survey_metadata (also named survey_completion) table\nsurvey_metadata_colnames &lt;- c(\n  \"count_miss1\", \"count_miss2\", \"progress\", \"start_date\", \"end_date\", \"temps_minute\"\n)\n\n# These are additional column names that are currently simply discarded for the MVP\n# TODO: figure out with Panel team what to do with these additional variables.\nextra_colnames &lt;- c(\n  \"particip_avant_changements\",\n  \"flag_troll\", , \"suppression_suite_v2\", \"flag_chgmt_pays\", \"mobile_ordi\",\n  \"avant_chgmt_vet\", \"flag_chgmt_localite_v2\"\n)\n\n# Prepare the questions and question_labels output\nquestions &lt;- wave2_data |&gt;\n  dplyr::select(\n    -tidyselect::all_of(participants_colnames),\n    -tidyselect::all_of(survey_metadata_colnames),\n    -tidyselect::all_of(extra_colnames)\n  )\n</code></pre> <p>Les colonnes avec les questions sont choisies.</p> <pre><code>questions &lt;- questions |&gt;\n  purrr::map(~ attr(.x, \"label\")) |&gt;\n  unlist() |&gt;\n  tibble::enframe(name = \"question_code\", value = \"question_text\")\n</code></pre> <p>Les labels des questions sont obtenus et tri\u00e9s dans un tibble</p> <pre><code>questions &lt;- questions |&gt;\n  dplyr::mutate(section_name = stringr::str_extract(question_code, \"^[:alpha:]+(?=\\\\_)\")) |&gt;\n  dplyr::mutate(section_name = dplyr::case_match(\n    section_name,\n    \"ali\" ~ \"Alimentation\",\n    \"con\" ~ \"Consommation\",\n    \"end\" ~ \"Satisfaction\",\n    \"ene\" ~ \"Energie\",\n    \"equ\" ~ \"Equipement\",\n    \"log\" ~ \"Logement\",\n    \"rep\" ~ \"Rep\",\n    \"temp\" ~ \"Temperature\",\n    \"vot\" ~ \"Votation\"\n  ))\n\n# Some of the questions include escape characters (\\n) that need to be removed\nquestions &lt;- remove_escapeseqs(questions)\n</code></pre> <p>Les noms des sections sont modifi\u00e9s, et les retour \u00e0 la ligne sont supprim\u00e9s avec la fonction <code>remove_escapeseqs</code>.</p> <pre><code>sections &lt;- questions |&gt;\n  dplyr::select(section_name) |&gt;\n  dplyr::group_by(section_name) |&gt;\n  dplyr::slice_head(n = 1) |&gt;\n  dplyr::ungroup()\n</code></pre> <p>Le fichier contenant les sections est pr\u00e9par\u00e9</p> <pre><code>participants &lt;- wave2_data |&gt;\n  dplyr::select(tidyselect::all_of(participants_colnames))\n\nparticipant_labels &lt;- get_labels(participants)\n\nparticipants &lt;- participants |&gt;\n  zap_all() |&gt;\n  dplyr::mutate(numero_insee = strtoi(numero_insee, base = 10L))\n</code></pre> <p>Les fichiers contenant les informations sur les participant\u00b7es et les labels des variables concern\u00e9es sont pr\u00e9par\u00e9s.</p> <pre><code>survey_completion &lt;- wave2_data |&gt;\n  dplyr::select(\n    participant_code, count_miss1, count_miss2, progress, start_date, end_date, temps_minute,\n    flag_troll\n  )\n\nsurvey_completion_labels &lt;- get_labels(survey_completion)\n\nsurvey_completion &lt;- survey_completion |&gt;\n  zap_all()\n</code></pre> <p>De m\u00eame pour le fichier avec les m\u00e9tadonn\u00e9es et les labels des variables concern\u00e9es.</p> <pre><code>responses &lt;- wave2_data |&gt;\n  dplyr::select(\n    -all_of(c(participants_colnames[-1], survey_metadata_colnames, extra_colnames))\n  ) |&gt;\n  zap_all()\n\nresponse_texts &lt;- pivot_responses(\n  responses,\n  selection_type = \"character\", remove_NAs = TRUE, names_to = \"question_code\",\n  values_to = \"response_text\"\n) |&gt;\n  remove_escapeseqs()\n\nresponse_values &lt;- pivot_responses(\n  responses,\n  selection_type = \"numeric\", remove_NAs = TRUE, names_to = \"question_code\",\n  values_to = \"response_value\"\n)\n\nresponses &lt;- response_values |&gt;\n  dplyr::bind_rows(response_texts)\n</code></pre> <p>Enfin, les r\u00e9ponses sont obtenues et format\u00e9es en format long avec la fonction <code>pivot_responses</code>.</p> <pre><code>readr::write_tsv(participant_labels, here::here(output_folder, \"participant_labels.tsv\"))\nreadr::write_tsv(participants, here::here(output_folder, \"participants.tsv\"))\nreadr::write_tsv(question_labels, here::here(output_folder, \"question_labels.tsv\"))\nreadr::write_tsv(questions, here::here(output_folder, \"questions.tsv\"))\nreadr::write_tsv(sections, here::here(output_folder, \"sections.tsv\"))\nreadr::write_tsv(survey_completion, here::here(output_folder, \"survey_completion.tsv\"))\nreadr::write_tsv(\n  survey_completion_labels, here::here(output_folder, \"survey_completion_labels.tsv\")\n)\nreadr::write_tsv(responses, here::here(output_folder, \"responses.tsv\"))\n</code></pre> <p>Les fichiers csv sont finalement \u00e9crits.</p> <pre><code>doubles_to_convert &lt;- setdiff(names(df), c(participants_colnames, survey_metadata_colnames, extra_colnames))\nwave2_data[doubles_to_convert] &lt;- double_to_integer(wave2_data[doubles_to_convert])\n</code></pre> <p>Les <code>&lt;double&gt;</code> sont transform\u00e9s en <code>&lt;integer&gt;</code> avec la fonction <code>double_to_integer</code> afin de faciliter l'int\u00e9gration dans OPAL.</p>"},{"location":"wave3/","title":"Vague 3: Mobilit\u00e9 II","text":"<p>Cette page documente le preprocessing de la troisi\u00e8me vague fait dans le fichier <code>preprocessing-wave3.R</code>.</p>"},{"location":"wave3/#fonctions-get_section","title":"Fonctions <code>get_section</code>","text":"<p>Les deux fonctions <code>get_section_W1</code> et <code>get_section_W3</code> fonctionnent comment la fonction <code>get_section</code> de la vague 1 et permettent de r\u00e9cup\u00e9rer les sections du questionnaire dans laquelle se trouve la question donnant en argument.</p>"},{"location":"wave3/#fonction-clean_embedded_adjectives","title":"Fonction <code>clean_embedded_adjectives</code>","text":"<ul> <li>Description: le but de cette fonction est de donner aux questions 97 \u00e0 100 un format comme \u00e0 la W1, donc trois colonnes pour chaque question, une par adjectif s\u00e9lectionn\u00e9. Les adjectifs sont ensuite labelled de 1 \u00e0 26. Dans la structure de FORS, les adjectifs \u00e9taient contenus dans des colonnes nomm\u00e9es EmbeddedDataCF_36 \u00e0 EmbeddedDataCF_61. Les adjectifs n'\u00e9taient en prime pas dans le m\u00eame ordre pour chaque participant. Il s'agissait donc de construire un dictionnaire des adjectifs et de reconstruire ensuite le choix des particpant\u00b7es dynamiquement, selon l'ordre des adjectifs dans leur ligne.</li> <li>Input: les donn\u00e9es brutes de la vague 3</li> <li>Output: les donn\u00e9es de la vague 3 avec les questions 97 \u00e0 100 recod\u00e9es</li> <li>D\u00e9tail:</li> </ul> <pre><code>questions &lt;- paste0(\"Q\", 97:100)\n  embedded_cols &lt;- paste0(\"EmbeddedData\", 36:61, \"_CF\")\n\n  # Extracts dynamically all the adjectives present\n  adjectives &lt;- data[embedded_cols] |&gt;\n    unlist(use.names = FALSE) |&gt;\n    as.character() |&gt;\n    trimws() |&gt;\n    unique()\n\n  adjective_list &lt;- adjectives[!is.na(adjectives) &amp; adjectives != \"\"]\n</code></pre> <p>Extrait la liste des adjectifs</p> <pre><code>  for (q in questions){\n    response_cols &lt;- paste0(q, \"_\", c(1:13, 21:33))\n\n    temp &lt;- purrr::pmap_dfr(\n      tibble::tibble(\n        responses = split(data[response_cols], seq_len(nrow(data))),\n        adjectives = split(data[embedded_cols], seq_len(nrow(data)))\n      ),\n      function(responses, adjectives){\n        responses &lt;- as.numeric(responses)\n        adjectives &lt;- as.character(adjectives)\n\n        selected_positions &lt;- which(responses == 1)\n        selected_adjectives &lt;- adjectives[selected_positions]\n        standardized &lt;- match(selected_adjectives, adjective_list)\n\n        tibble::tibble(\n          !!paste0(q, \"_adj1\") := standardized[1],\n          !!paste0(q, \"_adj2\") := standardized[2],\n          !!paste0(q, \"_adj3\") := standardized[3]\n        )\n      }\n    )\n</code></pre> <p>V\u00e9rifie quels adjectifs ont \u00e9t\u00e9 s\u00e9lectionn\u00e9s par chaque participant\u00b7e et les r\u00e9partit en trois colonnes</p> <pre><code>temp &lt;- temp |&gt;\n      dplyr::mutate(\n        dplyr::across(\n          everything(),\n          ~ haven::labelled(.x, labels)\n        )\n      )\n\n    results[[q]] &lt;- temp\n  }\n  final_result &lt;- dplyr::bind_cols(results)\n</code></pre> <p>Les labels sont ajout\u00e9s aux adjectifs</p> <pre><code>questions_labels &lt;- c(\n    \"97\" = \"Pouvez-vous citer trois adjectifs qui vous paraissent les plus adapt\u00e9s pour qualifier la voiture ? - Adjectif \",\n    \"98\" = \"Pouvez-vous citer trois adjectifs qui vous paraissent les plus adapt\u00e9s pour qualifier le train (y compris L\u00e9man Express) ? - Adjectif \",\n    \"99\" = \"Pouvez-vous citer trois adjectifs qui vous paraissent les plus adapt\u00e9s pour qualifier les autres transports publics (m\u00e9tro, tram, bus) ? - Adjectif \",\n    \"100\" = \"Pouvez-vous citer trois adjectifs qui vous paraissent les plus adapt\u00e9s pour qualifier le v\u00e9lo (conventionnel ou \u00e9lectrique) ? - Adjectif \"\n  )\n</code></pre> <p>Les labels des questions sont cr\u00e9es</p> <pre><code>texte_map &lt;- list(\n    \"Q97_TEXTE\" = \"Autre_TEXTE_voiture\",\n    \"Q98_TEXTE\" = \"Autre_TEXTE_train\",\n    \"Q99_TEXTE\" = \"Autre_TEXTE_autresTPs\",\n    \"Q100_TEXTE\" = \"Autre_TEXTE_velo\"\n  )\n\n  for (q_num in 97:100) {\n    q &lt;- paste0(\"Q\", q_num)\n    new_colname &lt;- paste0(q, \"_TEXTE\")\n    source_col &lt;- texte_map[[new_colname]]\n\n    if (source_col %in% names(data)) {\n      text_vector &lt;- as.character(data[[source_col]])\n      text_vector[text_vector == \"\" | text_vector == \"-99\"] &lt;- NA\n\n      text_col &lt;- haven::labelled(\n        text_vector,\n        label = paste0(\n          gsub(\" - Adjectif $\", \"\", questions_labels[as.character(q_num)]),\n          \" - Autre adjectif (texte libre)\"\n        )\n      )\n\n      # Trouver position d'insertion apr\u00e8s Qxx_adj3\n      insertion_point &lt;- match(paste0(q, \"_adj3\"), names(final_result)) + 1\n\n      if (insertion_point &gt; ncol(final_result)) {\n        final_result &lt;- dplyr::bind_cols(\n          final_result,\n          tibble::tibble(!!new_colname := text_col)\n        )\n      } else {\n        final_result &lt;- dplyr::bind_cols(\n          final_result[ , 1:(insertion_point - 1)],\n          tibble::tibble(!!new_colname := text_col),\n          final_result[ , insertion_point:ncol(final_result)]\n        )\n      }\n    } else {\n      warning(\"Colonne manquante dans les donn\u00e9es : \", source_col)\n    }\n  }\n</code></pre> <p>Les participant\u00b7es avaient \u00e9galement la possibilit\u00e9 de rajouter des adjectifs en cliquant sur \"Autre\". Ces r\u00e9ponses sous forme de texte sont r\u00e9cup\u00e9r\u00e9es, labeled et ajout\u00e9es dans le tibble au bon endroit.</p> <pre><code>to_remove_q &lt;- unlist(lapply(97:100, function(q) paste0(\"Q\", q, \"_\", c(1:13, 21:33))))\n  to_remove_embedded &lt;- paste0(\"EmbeddedData\", 36:61, \"_CF\")\n\n  adjectif_suffixes &lt;- c(\"voiture\", \"train\", \"autresTPs\", \"velo\")\n  pattern &lt;- paste0(\"^[^Q].*_(\", paste(adjectif_suffixes, collapse = \"|\"), \")$\")\n  to_remove_adjectif &lt;- grep(pattern, names(data), value = TRUE)\n\n  to_remove &lt;- c(to_remove_q, to_remove_embedded, to_remove_adjectif)\n\n  insert_pos &lt;- min(which(names(data) %in% to_remove_q))\n\n  data_cleaned &lt;- data[ , !(names(data) %in% to_remove)]\n  before &lt;- data_cleaned[ , 1:(insert_pos - 1), drop = FALSE]\n  after  &lt;- data_cleaned[ , insert_pos:ncol(data_cleaned), drop = FALSE]\n\n  data_final &lt;- dplyr::bind_cols(before, final_result, after)\n</code></pre> <p>Les colonnes obsol\u00e9tes sont supprim\u00e9es et les colonnes nouvellement cr\u00e9es ins\u00e9r\u00e9es \u00e0 leur place.</p> <pre><code>for (q in 97:100) {\n    for (adj_num in 1:3) {\n      colname &lt;- paste0(\"Q\", q, \"_adj\", adj_num)\n      if (colname %in% names(data_final)) {\n        attr(data_final[[colname]], \"label\") &lt;- paste0(\n          questions_labels[as.character(q)],\n          adj_num\n        )\n      }\n    }\n  }\n</code></pre> <p>Les colonnes sont labellis\u00e9es.</p>"},{"location":"wave3/#fonction-write_files_questions","title":"Fonction <code>write_files_questions</code>","text":"<p>Reprend la structure de la m\u00eame fonction dans la vague 1. N\u00e9anmoins, certaines questions de la vague 1 \u00e9taient reprises sous la forme <code>W1_q*</code>. La section de ces questions dans le questionnaire de la vague 1 est obtenue avec la fonction [<code>get_section_W1][wave3.md#fonction-get_section], tandis que pour les questions de la vague 3, la section est obtenue avec</code>get_section_W3`.</p> <p>Comme certaines questions sont les m\u00eames entre les vagues 1 et 3, une nouvelle colonne a \u00e9t\u00e9 cr\u00e9\u00e9e, indiquant si une question de la vague 3 reprenait une question de la vague 1. Cette colonne est cr\u00e9\u00e9e avec:</p> <pre><code>if (length(matches) &gt; 0) {\n          original_match &lt;- names(data)[tolower(names(data)) == matches[1]]\n          lien_avec_W1 &lt;- c(lien_avec_W1, original_match)\n        } else {\n          lien_avec_W1 &lt;- c(lien_avec_W1, NA_character_)\n        }\n      } else {\n        # Si ce n\u2019est pas une Q de W3, alors pas de lien\n        lien_avec_W1 &lt;- c(lien_avec_W1, NA_character_)\n      }\n</code></pre> <p>Pour certaines questions, la section ainsi que le lien avec la question de la W1 a \u00e9t\u00e9 attribu\u00e9 manuellement:</p> <pre><code>num &lt;- suppressWarnings(as.integer(stringr::str_extract(i, \"(?i)(?&lt;=q)\\\\d+\")))\n\n      if (stringr::str_detect(i, \"Q320|Q285|Q291\")) {\n        section_name &lt;- c(section_name, \"W3- Travail/Formation\")\n      } else if (stringr::str_detect(i, \"Q218\")) {\n        section_name &lt;- c(section_name, \"W3- Activit\u00e9s\")\n      } else if (stringr::str_detect(i, \"^Q303(_\\\\d+)?$\")) {\n        section_name &lt;- c(section_name, \"W3- S\u00e9jours\")\n      } else if (stringr::str_detect(i, \"Q129_R\")) {\n        section_name &lt;- c(section_name, \"W3- Satisfaction\")\n      } else if (stringr::str_detect(i, \"W1\")) {\n        section_name &lt;- c(section_name, get_section_W1(num))\n      } else {\n        section_name &lt;- c(section_name, get_section_W3(num))\n      }\n\n      if (stringr::str_detect(i, \"^Q325(_\\\\d+)?$\")) {\n        lien_avec_W1 &lt;- c(lien_avec_W1, \"W1_q117\")\n      } else if (stringr::str_detect(i, \"^Q326(_\\\\d+)?$\")) {\n        lien_avec_W1 &lt;- c(lien_avec_W1, \"W1_q118\")\n      } else if (stringr::str_detect(i, \"^Q327(_\\\\d+)?$\")) {\n        lien_avec_W1 &lt;- c(lien_avec_W1, \"W1_q119\")\n      } else if (stringr::str_detect(i, \"^Q\\\\d+\")) {\n        prefix &lt;- paste0(\"w1_q\", num)  # lower\n        pattern &lt;- paste0(\"^\", prefix, \"(_|$)\")\n</code></pre>"},{"location":"wave3/#fonction-write_files_embeddeddata","title":"Fonction <code>write_files_embeddeddata</code>","text":"<p>Les adjectifs des questions 97 \u00e0 100 n'\u00e9taient pas les seules informations stock\u00e9es dans des EmbeddedData. Cette fonction liste donc les autres EmbeddedData ainsi que leur label.</p>"},{"location":"wave3/#fonction-write_file_section","title":"Fonction <code>write_file_section</code>","text":"<p>Similaire \u00e0 la vague 1.</p>"},{"location":"wave3/#fonction-documentation","title":"Fonction <code>documentation</code>","text":"<p>Similaire \u00e0 la vague 1</p>"},{"location":"wave3/#fonction-write_label_file","title":"Fonction <code>write_label_file</code>","text":"<p>Similaire \u00e0 la vague 1</p>"},{"location":"wave3/#fonction-write_files_survey_completion","title":"Fonction <code>write_files_survey_completion</code>","text":"<p>Similaire \u00e0 la vague 1</p>"},{"location":"wave3/#fonction-write_files_participants","title":"Fonction <code>write_files_participants</code>","text":"<p>Similaire \u00e0 la vague 1. N\u00e9anmois, certaines variables ont \u00e9t\u00e9 rajout\u00e9es:</p> <ul> <li> <p>Les variables FlagAvantLancement et FlagPrblmStatut</p> </li> <li> <p>Les variables Titre_source et Titre_actuel, repr\u00e9sentant le titre avec lequel les participant\u00b7es aimeraient \u00eatre adress\u00e9\u00b7es (M, Mme, ...)</p> </li> <li> <p>Les variables code_raison_contact, indiquant la raison pour une potentielle prise de contact avec FORS.</p> </li> </ul>"},{"location":"wave3/#fonction-main","title":"Fonction <code>main</code>","text":"<p>Principalement similaire \u00e0 la vague 1. Les sp\u00e9cificit\u00e9s sont list\u00e9es ci-dessous:</p> <pre><code>geodata &lt;- \"geolocalised_data.csv\"\nraw_q129 &lt;- \"EPFL-PanelL\u00e9manique-Vague3-mobilit\u00e9_Q129 anonymis\u00e9e_EPFL-NOPASSWORD.sav\"\n</code></pre> <p>Certaines g\u00e9odonn\u00e9es dans les donn\u00e9es brutes de FORS \u00e9taient sous forme d'adresses, d'autres en tant que coordonn\u00e9es. Les g\u00e9odonn\u00e9es sous forme d'adresses ont donc \u00e9t\u00e9 g\u00e9ocod\u00e9es dans un fichier \u00e0 part et sont import\u00e9es ici.</p> <p>De plus, FORS a envoy\u00e9 des donn\u00e9es manquantes dans un fichier s\u00e9par\u00e9, elles sont donc charg\u00e9es ici (<code>raw_Q129</code>).</p> <pre><code>wave3_data &lt;- wave3_data[, -which(names(wave3_data) == \"W1_q112\")]\nattr(wave3_data$Q112_regroup, \"label\") &lt;- \"Quelle profession exercez-vous actuellement?\"\n  attr(wave3_data$Q114_regroup, \"label\") &lt;- \"Quelle profession exercez-vous actuellement?\"\n  attr(wave3_data$Q41_regroup, \"label\") &lt;- \"En moyenne, combien de jours par semaine travaillez-vous ? - regroup\u00e9\"\n</code></pre> <p>La question <code>W1_q112</code> \u00e9tant vide, elle est supprim\u00e9e. Les labels des questions 112, 114 et 41 sont rajout\u00e9s manuellement</p> <pre><code>coords_csv &lt;- coords_csv |&gt;\n    dplyr::rename(Q14 = lat_lng)\n\n  names(coords_csv)[2:ncol(coords_csv)] &lt;- paste0(names(coords_csv)[2:ncol(coords_csv)], \"_geocoded\")\n  coords_csv$Q14_geocoded[coords_csv$Q14_geocoded == \"NA,NA\"] &lt;- NA\n\n  # Labels the variables from coords_csv\n  for (col in names(coords_csv)) {\n    if (endsWith(col, \"_geocoded\")) {\n      original_col &lt;- sub(\"_geocoded$\", \"\", col)\n\n      if (original_col %in% names(wave3_data)) {\n        label &lt;- attr(wave3_data[[original_col]], \"label\")\n        if (!is.null(label)) {\n          attr(coords_csv[[col]], \"label\") &lt;- label\n        }\n      }\n    }\n  }\n\n  wave3_data &lt;- dplyr::left_join(wave3_data, coords_csv, by = \"IDNO\")\n</code></pre> <p>Les g\u00e9odonn\u00e9es sont labellis\u00e9es et rajout\u00e9es au reste des donn\u00e9es</p> <pre><code>cols_to_process &lt;- c(\"Q14\", \"W1_q14\", \"Q14_regroup\", \"Q43\", \"Q48\", \"W1_q48\", \"Q48_regroup\", \"Q50\", \"W1_q50\", \"Q50_regroup\", \"Q51\", \"W1_q51\", \"Q51_regroup\")\n  for (col in cols_to_process) {\n    lbl &lt;- attr(wave3_data[[col]], \"label\")\n    wave3_data[[col]] &lt;- sapply(wave3_data[[col]], extract_lat_lng)\n    attr(wave3_data[[col]], \"label\") &lt;- lbl\n  }\n</code></pre> <p>Elles sont ensuite reformat\u00e9es \u00e0 l'aide de <code>extract_lat_lng</code>.</p> <pre><code>cols_to_replace &lt;- setdiff(names(Q129), c(\"Q129_R\", \"IDNO\"))\n  for (colname in cols_to_replace) {\n    Q129[[colname]][is.na(Q129[[colname]])] &lt;- 0\n  }\n\n  Q129 &lt;- dplyr::select(Q129, IDNO, Q129_R, Opt_Out_de_tout_le_projet, FlagAutreRepQ129_R) %&gt;%\n    dplyr::rename(Suppression_Q129_W3C5 = Opt_Out_de_tout_le_projet)\n\n  wave3_data &lt;- dplyr::left_join(wave3_data, Q129, by = \"IDNO\")\n</code></pre> <p>Les colonnes importante du fichier <code>raw_q129</code> sont rajout\u00e9es aux donn\u00e9es de base.</p>"}]}